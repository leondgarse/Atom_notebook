# ___2013 - 06 - 17 Java基础___
***

# Q / A
  - 类中的方法名可以与类名相同，但构造方法是没有返回类型的方法
  - Java并不提供无符号整数类型，因此在读取无符号整数时，必须存为长整型，否则符号位将被丢失
  - 浮点数默认为double型，若要赋给float型，需类型转换：float f = 3.14f;
  - 在可以使用变量之前，实际内存必须被分配，这个工作是通过使用关键字 new 来实现的，但在声明时即为引用用分配了足够的空间，通过调用对象的构造方法为构成类的属性分配空间
  - **文档注释**：/** ... \*/仅放在变量、方法或类的声明之前的文档注释，表明该注释应该被放在自动生成的文档中
  - **代码块**：当前构造对象时在构造方法被调用时执行，需要用{}单独括起来
  - **初始化块**：需要用{}扩起来，不属于方法；不管使用哪个构造器创建对象，它都会被首相执行
  - **Java垃圾回收**：垃圾回收是一个系统行为，程序员不能控制，但可以通过调用System.gc()或设置对象为bull来通知系统该对象可以被回收了
  - **java中定义一个方法的组成**：访问修饰符 返回类型 方法名(参数列表) throws XXXExcption
  - **this** 代表定义类的当前对象，this是冗余信息，需要时才使用，可调用本类的另外的构造方法，用this调用其他构造方法时，this必须为第一条语句，然后才是其他语句
***

# 命名规则：类名/接口名首字母大写，单词首字母大写
  - 变量名/方法名首字母小写，单词首字母大写
  - 常量全部使用大写，并用下划线分隔(final关键字修饰)
***

# 一个 Java 源文件可包含三个“顶级”要素
  - 一个包(package)声明(可选)
  - 任意数量的导入(import)语句
  - 类(class)声明
  - 该三要素必须以上述顺序出现
***

# java是oop语言，但是不纯的oop语言
  - 基本类型，简单类型
  - 静态成员
***

# Java程序的运行
  - 编写代码
  - 编译，生成class文件
  - 类装载classloader
  - 字节码(byte-code)校验
  - 解释、运行
    - 首先打开一个Java的运行环境
    - 随后加载一个特殊的类，并从其中的main方法开始执行
    - 该方法必须被声明为 public static
    - public说明方法 main()可被任何程序访问，包括Java解释器，且只能有一个public类
    - static是一个告知编译器 main()是用于类HelloWorldApp中的方法的关键字
    - 为使 main()在程序做其它事之前就开始运行,这一关键字是必要的
    - 不能带任何返回值，并需要接收一个String类型的参数
    ```java
    public static void main(String args[]);
    ```
***

# 初始化过程：初始化的顺序是先静态对象，而后是非静态对象
  - 第一家次创建类的对象或调用类的静态方法/静态字段，会加载类class文件
  - 加载class文件后有关静态初始化的所有动作会执行
  - 当用new创建对象时，首先在堆上为类对象分配足够存储空间
  - 将这个存储空间清零，所有基本类型设置为缺省值，引用为null
  - 执行所有出现于字段定义处的初始化动作
  - 执行构造方法，当有继承时会涉及更多的动作
***

# Java虚拟机JVM
  - 相当于Java运行环境，基本功能
    - 通过classloader寻找和装载从class文件
    - 解释字节码成为指令并执行,提供 class 文件的运行环境
    - 进行运行期间垃圾回收
    - 提供与硬件交互的平台
  - 虚拟机代码被存储在.class 文件中;每个文件都包含最多一个 public 类
***

# Java中的几个关于类的关键字
  - abstract：表明类或类中的方法是抽象的
  - catch：用于处理例外情况，用来捕捉异常
  - class：类
  - extends：用来表明一个类是另一个类的子类
  - final：用来表明一个类不能派生出子类，或类中的方法不能被覆盖，或声明一个变量是常量
  - finally：用于处理异常情况，用来声明一个肯定会被执行到的块
  - implements：表明一个类实现了给定的接口
  - import：表明要访问指定的类或包
  - instanceof：接口
  - native：用来声明一个方法是由与机器相关的语言(如 C/C++/FORTRAN 语言)实现的
  - new：用来申请新对象
  - package：包
  - private：一种访问方式，私有模式，同一类中可访问，null表示同一个包中可访问
  - protected:一种访问方式，保护模式，不同包中的子类的对象
  - public：一种访问方式，公共模式，任何场合可访问
  - static：表明域或方法是静态的,即该域或方法是属于类的
  - super：当前对象的父类对象的引用
  - synchronized：表明一段代码的执行需要同步
  - this：当前对象的引用
  - throw：抛出一个异常
  - throws：声明方法中抛出的所有异常
  - transient：声明不用序列化的域
  - try：尝试一个可能抛出异常的程序块
  - volatile：表明两个或多个变量必须同步地发生变化
***

# JAR文件：是把相关的class文件及资源文件打包成一个文件
  ```shell
  Jar cf test.jar *.class # 打包文件
  Jar tf test.jar # 查看文件
  Java -jar test.jar # 运行jar文件
  ```
***

# java中的包
  - 包是一组相关类的集合，有助于避免命名冲突，从物理上讲，同包即同目录
  - java.lang：包含一些 Java 语言的核心类，包含构成 Java 语言设计基础的类，在此包中定义的最重要的一个类是“ Object“，代表类层次的根，Java 是一个单根系统，最终的根就是Object
  - java.awt：包含了构成抽象窗口工具集(abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)
  - javax.swing：完全 Java 版的图形用户界面 (GUI)解决方案，提供了很多完备的组件，可以应对复杂的桌面系统构建
  - java.net：包含执行与网络相关的操作的类，如 URL, Socket, ServerSocket等
  - java.io：包含能提供多种输入/输出功能的类
  - java.util：包含一些实用工具类，如定义系统特性、使用与日期日历相关的方法。还有重要的集合框架
  - 包导入
    ```java
    package pkg1[.pkg2[.pkg3...]];  // [] 表示可选
    //导入包，应位于package语句之后，java.lang包是自动导入的，非java.lang必须是显示导入，否则编译出错
    import package1[.package2...].(classname|* );
    ```
***

# java中的参数传递
  - 在 Java 里面参数传递都是按值传递，按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递
  - 在 Java 里面只有基本类型和直接使用双引号定义字符串方式定义的 String 是按值传递，其它的都是按引用传递
***

# Java 变量的范围
  - Java 变量的范围有四个级别:类级、对象实例级、方法级、块级
  - **类级变量** 又称全局级变量，在对象产生之前就已经存在，用 static 修饰的属性
  - **对象实例级**：属性变量
  - **方法级**：就是在方法内部定义的变量，就是局部变量
  - **块级**：就是定义在一个块内部的变量，变量的生存周期就是这个块
***

# static静态成员属于类所有，可通过类名直接调用
  - 静态的方法需注意：
    - 仅可调用其他static方法，只能访问static数据
    - 静态块仅在类被加载时执行一次，只能初始化静态成员
    - 一个 static 变量只会有一个内存空间，虽然有多个类实例，但这些类实例中的这- 个static变量会共享同一个内存空间
    - 如访问控制权限允许，static 属性和方法可以使用类名加“.”方式调用
    - 静态方法中不存在当前对象，因而不能使用“this”，当然也不能使用”super”
    - 静态方法不能被非静态方法覆盖
    - 构造方法不允许声明为 static 的
    - 局部变量不能使用 static 修饰
  - static import：静态引用使我们可以象调用本地方法一样调用一个引入的方法
***

# 数组
  - 在 java.util 包中，有一个用于操纵数组的实用类 Arrays，提供了一系列静态方法
  - 当数组声明的方括号在左边时,该方括号可应用于所有位于其右的变量
  - 一个数组中元素的数量被作为具有length 属性的部分数组对象而存储
  - 更优化的for循环语句
    ```java
    for (int i : a) --> for (int i = 0; i < a.length; i++)
    ```
  - 数组的复制：可使用相同的引用变量来引用一个全新的数组 System.arrycopy方法
  - 数组排序：java.util.Arrays.sort方法(升序)
***

# 继承
  - JAVA中不允许多继承，一个类有且只有一个父类(单继承)，通过接口和内部类实现多继承
  - 子类自动拥有父类的属性和方法，但不能继承构造方法，子类在构造对象时会调用父类的构造方法
  - 对于覆盖方法的修饰词，子类方法要比父类的方法范围更加的宽泛
  - 使用extends关键字来表达继承关系，有继承的类在运行的时候，初始化子类必先初始化父类
    ```java
    Class Son extends Father{ ... }
    ```
  - super关键字
    - 必须放在第一行
    - 调用基类的构造方法，作为方法名表示基类的构造方法
    - 访问基类中被子类隐藏了的成员列表
    - 访问基类中被重写的方法
  - 父类可引用子类的对象，父类可实现通用功能，实现通用的接口
***

# 多态性
  - 多态分两种
    - 编译时多态：编译时动态重载
    - 运行时多态：指一个对象可以具有多个类型
  - 父类引用变量可以引用子类的对象，在运行时根据当前被引用对象的类型来决定执行哪个版本的方法叫动态绑定
  - java中对象的绑定大部分是动态绑定，除了静态绑定(static方法 final方法 private方法)
    ```java
    Employee e = new Manager();
    ```
    - 在使用变量 e 时，能访问的对象部分只是 Employee 的一个部分，Manager 的特殊部- 分是隐藏的
    - e 是一个 Employee，而不是一个 Manager
    - 如果要使用Manager的全部功能，可以显示的强制类型转换
  - 运行时的动态类型判定针对的是方法，运行程序访问的属性仍为编译时属性
  - 规则是：编译时看数据类型，运行时看实际的对象类型(new 操作符后跟的构造方法是哪个类的，new 谁就调用谁的方法
  - 下述规则适用于覆盖方法
    - 覆盖方法的返回类型、方法名称、参数列表必须与它所覆盖的方法的相同
    - 覆盖方法不能比它所覆盖的方法访问性差(即访问权限不允许缩小)
    - 覆盖方法不能比它所覆盖的方法抛出更多的异常
    - 覆盖不适用于静态方法
  - instanceof运算符，用来判断某个实例变量是否属于某种类的类型
    ```java
    public void method(Employee e) {
        if (e instanceof Manager) {
            // 如果雇员是经理,可以做的事情写在这里
        } else if (e instanceof Contractor) {
            // 如果雇员是普通的职员,可以做的事情写在这里
        } else {
            // 说明是临时雇员,可以做的事情写在这里
        }
    }
    ```
***

# final关键字
  - final 标记的类不能被继承
  - final 标记的方法不能被子类重写
  - final 标记的变量(成员变量或局部变量)即成为常量，只能赋值一次
  - final一般用于标记那些通用性的功能、实现方式或取值不能随意被改变的成分，以避免被误用
  - 在JAVA中利用public static final的组合方式对常量进行标识（固定格式）
  - 如果一个方法前有修饰词 private 或 static，则系统会自动在前面加上final，即 private 和 static 方法默认均为final方法
***

# 抽象类(abstract)
  - abstract 修饰符可以与类和方法一起使用，被修饰的类不能被实例化，被修饰的方法必须在包含此方法的类的子类中被实现
  - 只给出方法定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”
  - 抽象类不能直接使用,必须用子类去实现抽象类,然后使用其子类的实例
  - 可以用抽象类充当形参，实际实现类作为实参，也就是多态的实现
  - 不能有抽象构造方法或抽象实现方法
  - 抽象类的子类需要提供父类中的所有抽象方法的实现，否则它们也是抽象类
***

# 接口(interface)
  - 接口与类属于同一层次，在一个文件中不可同时定义一个public接口和一个public类
  - 接口是完全没有任何方法被实现的抽象类，可以利用接口实现多态，同时弥补了Java单一继承的弱点
  - 接口中定义的抽象方法默认是public abstract，接口中定义属性默认是public static final，且必须显示地初始化
  - 使用interface关键字定义接口，使用implements关键字来实现接口。如果一个类不能实现该接口的所有抽象方法,那么这个类必须被定义为抽象方法
  - 接口可以作为一个类型来使用，把接口作为方法的参数和返回类型
  - 抽象类与接口对比
    - 抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势
    - 一个类只能继承一个直接的父类(可能是抽象类)，但一个类可以实现多个接口，这个就接口的优势
  - 规则
    - 优先选用接口，尽量少用抽象类
    - 需要定义子类的行为，又要为子类提供共性的功能时才选用抽象类
***

# 匿名内部类
  - 可以不声明类名称，而直接使用new产生一个对象，它可以继承某个类或实现某个接口
    ```
    new [类或接口()] {
        //实现
    }
    ```
***

# 异常
  - 在 Java 编程语言中，异常是指当程序出错时创建的一种特殊的运行时错误对象，包括
    - 程序在编译时检查出异常(不是语法错误)(可检查异常)
    - 程序在运行时出现的异常(不可检查异常)
  - java.lang.Throwable类充当所有对象的父类，它有Error和Exception两个基本子类
  - Java 创建异常对象后，就发送给 Java 程序，即抛出异常(throwing an exception)
  - 程序捕捉到这个异常后，可以编写相应的异常处理代码进行处理，而不是让程序中断
  - Java 中对异常的处理有两种方法
    - 一个就是 try-catch，然后自己处理
    - 一个就是不做处理，向外 throws，由调用该方法的代码去处理
  - 模型
    ```java
    try {
        // 放置可能出现异常的代码
    } catch (Exception1 el) {
        // 如果 try 块抛出异常对象的类型为 Exceptionl,那么就在这里进行处理
    } catch (Exception2 e2) {
        // 如果 try 块抛出异常对象的类型为 Exception2,那么就在这里进行处理
    } catch (ExceptionN eN) {
        // 如果 try 块抛出异常对象的类型为 ExceptionN,那么就在这里进行处理
    } finally {
        // 不管是否有异常发生,始终执行这个代码块
    }
    ```
  - 一旦执行了catch语句，程序控制从整个try/catch机制的下面一行继续
  - 当多个 catch 块存在的时候，从上往下 catch 异常的范围应该从小到大
  - finally 块表示无论是否出现异常，都会运行的块，通常编写释放资源、关闭连接的的语句
  - 异常的抛出
    - throw语句：throw 的操作数是任一种异常类对象。是 Throwable 类类型或 Throwable 子类类型的一个对象
      ```java
      throw new NullPointerException("demo");
      ```
    - throws语句：用来在方法定义时声明异常，告诉调用该方法的程序员，注意使用该方法会产生的异常
  - Exception有一个message属性，在使用catch的时候可以调用，输出出错类型所历经的过程：
    ```java
    Catch(IOException e){System.out.println(e.message())};
    Catch(IOException e){e.printStackTrace()};
    ```
  - 规则
    - 对于 Error 和 RuntimeException，可以在程序中进行捕获和处理，但不是必须的
    - 对于其它异常，必须在程序中进行捕获和处理。
    - 如果前面的程序代码块抛出的错误影响了后面程序代码的运行，那么这个我们就说这两个程序代码存在关联，应该放在同一个try中
    - 对已经查出来的例外，有throw(积极)和try catch（消极）两种处理方法，对于try catch 放在能够很好地处理例外的位置（即放在具备对例外进行处理的能力的位置），如果没有处理能力就继续上抛
    - 如果父类型无throws时，子类型也不允许出现throws，此时只能使用try catch
***

# 断言
  - 断言是一种调试工具，用于证明和测试程序的假设，比如“这里的值大于 5”
  - 断言可以在运行时从代码中完全删除，所以对代码的运行速度没有影响
    ```java
    assert<<布尔表达式>> ;
    assert<<布尔表达式>> :<<细节描述>>
    ```
  - 使用以下的命令编译代码
    ```shell
    javac -source 1.4 文件名.java
    ```
  - 运行使用断言功能需要使用额外的参数
    ```shell
    java –enableassertions 或 java -ea 类名
    ```
  - 运行时要屏蔽断言，使用如下方法
    ```shell
    java –disableassertions 或 java –da 类名
    ```
  - 规则
    - 用于验证方法中的内部逻辑，如内在不变式 / 控制流程不变式 / 后置条件 / 类的不变式
    - 不推荐用于公有方法的前置条件的检查
***
