# ___2013 - 07 - 17 ARM内核SOC基础___
***

# 目录
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [___2013 - 07 - 17 ARM内核SOC基础___](#2013-07-17-arm内核soc基础)
- [目录](#目录)
- [Q / A](#q-a)
- [ARM基础知识](#arm基础知识)
	- [冯·诺依曼体系架构特点](#冯诺依曼体系架构特点)
	- [常见存储器](#常见存储器)
	- [CPU / 系统总线 / 控制器](#cpu-系统总线-控制器)
	- [最小系统](#最小系统)
	- [S5PC100(集成SOC片上系统)存储结构](#s5pc100集成soc片上系统存储结构)
- [ARM体系结构](#arm体系结构)
	- [ARM advanced RISC machine 系列芯片](#arm-advanced-risc-machine-系列芯片)
	- [ARM 数据和指令类型中断服务程序 ISR Interrupt Service Routines](#arm-数据和指令类型中断服务程序-isr-interrupt-service-routines)
	- [ARM 处理器运行模式](#arm-处理器运行模式)
	- [ARM 寄存器 37个32位寄存器](#arm-寄存器-37个32位寄存器)
	- [ARM协处理器](#arm协处理器)
	- [Thumb指令集](#thumb指令集)
	- [SOC概念](#soc概念)
	- [指令流水线](#指令流水线)
- [ARM 指令集](#arm-指令集)
	- [简介](#简介)
	- [指令的条件码 16个](#指令的条件码-16个)
	- [操作数寻址方式](#操作数寻址方式)
	- [立即数](#立即数)
	- [分支跳转指令](#分支跳转指令)
	- [数据处理指令](#数据处理指令)
	- [数据移位指令](#数据移位指令)
	- [其他指令](#其他指令)
	- [单寄存器数据传送 Load / Store 指令的寻址方式](#单寄存器数据传送-load-store-指令的寻址方式)
	- [批量Load / Store指令的寻址方式(LDM / SDM)](#批量load-store指令的寻址方式ldm-sdm)
	- [SWP / SWPB 软交换](#swp-swpb-软交换)
	- [软件中断 SWI](#软件中断-swi)
	- [断点中断指令 BKPT](#断点中断指令-bkpt)
	- [PSR 传送指令](#psr-传送指令)
	- [指令示例](#指令示例)
- [ARM 中的伪指令(伪指令：运行时没有一一对应的机器码)](#arm-中的伪指令伪指令运行时没有一一对应的机器码)
	- [符号定义伪操作](#符号定义伪操作)
	- [数据定义伪操作](#数据定义伪操作)
	- [汇编控制伪操作](#汇编控制伪操作)
	- [信息报告伪操作](#信息报告伪操作)
	- [其他的伪操作](#其他的伪操作)
- [ARM 中的存储系统](#arm-中的存储系统)
	- [存储管理系统控制协处理器 CP15](#存储管理系统控制协处理器-cp15)
	- [存储器管理单元MMU](#存储器管理单元mmu)
- [ARM 中异常处理](#arm-中异常处理)
	- [异常类型(中断向量表)](#异常类型中断向量表)
	- [ARM 中的异常中断处理机制](#arm-中的异常中断处理机制)
	- [异常返回指令](#异常返回指令)
	- [异常向量表跳转指令](#异常向量表跳转指令)
	- [IRQ / FIQ异常中断处理](#irq-fiq异常中断处理)
	- [SWI软中断处理](#swi软中断处理)
	- [复位异常中断处理程序](#复位异常中断处理程序)
- [清BSS段例程(初始值为0、无初始值的全局变量、静态变量放在BSS段)](#清bss段例程初始值为0无初始值的全局变量静态变量放在bss段)
- [C / 汇编编译器提示和技巧](#c-汇编编译器提示和技巧)
- [ARM 映像文件](#arm-映像文件)
- [Linux 内核中使用汇编代码](#linux-内核中使用汇编代码)
- [ARM 与 C 混合编程](#arm-与-c-混合编程)
	- [寄存器使用规则](#寄存器使用规则)
	- [数据栈使用规则](#数据栈使用规则)
	- [参数传递规则](#参数传递规则)
	- [子程序结果返回规则](#子程序结果返回规则)
	- [汇编调用C代码中标号（函数、变量）举例](#汇编调用c代码中标号函数变量举例)
	- [C程序引用汇编代码中标号举例](#c程序引用汇编代码中标号举例)

<!-- /TOC -->
***

# Q / A
  - subs：s表示设置标志位
  - movs pc, lr @ 目标寄存器为pc时，s表示将spsr赋值给cpsr，用于从异常模式返回
  - IRQ中断处理函数中应在第一条指令使用 sub lr, lr, #4，如果在最后使用sub pc, lr, #4 容易造成死机
    ```python
    HandleIRQ:
            sub lr, lr, #4
            stmfd sp!, {r0-r12, lr}
            bl c_irq_handler
            ldmfd sp!, {r0-r12, pc}^

    ```
  - 若在程序中使用寄存器变量(r8)，编译时可使用 -ffixed-r8 选项，以保留该寄存器用于特定的变量
***

# ARM基础知识
## 冯·诺依曼体系架构特点
  - 数据和指令采用二进制表示，软件体系依附于硬件体系，并在其上层完成具体的逻辑功能
  - 计算机硬件系统由运算器、控制器、存储器、输入设备、输出设备五大部件组成
## 常见存储器
  - **RAM 掉电丢失数据** 静态SRAM(本课程中为96KB) / 动态DRAM(SDRAM、DDRII(本课程中为256MB))，需要定时刷新
  - **ROM掉电不丢失数据** EPROM/E2PROM
  - **flash**
    - **norflash** 或非门设计，有地址线，CPU可直接访问，可片上执行，读取速度快，一般用来存储启动程序，缺点：容量小、价格高、支持文件系统少。(本课程中为2MB)
    - **nandflash** 无地址线，不能片上执行，容量大，存储大量数据。(本课程中为256MB)
    - **onenand** 容量大，读取速度快，具有以上两种flash的优点，固态硬盘中使用
## CPU / 系统总线 / 控制器
  - **CPU** CU + ALU，执行解释和执行指令的功能部件，CU 译码，发出各种控制信号，ALU 运算
  - **系统总线** 数据总线DB(代表MCU位数)、地址总线AB(内存可寻址范围)、控制总线CB
  - **控制器** 硬件中与总线进行通信的部件，可编程、抗干扰、可缓冲
## 最小系统
  - **最小系统** 晶振(时钟系统)、CPU、电源、复位电路
  - **嵌入式控制器**
    - 供电系统
    - 时钟系统
    - 复位及其配置系统，上电复位 / RC电路 / 复位芯片
    - 存储器系统，可选，许多面向嵌入式领域的微控制器内部集成
    - 调试测试接口 可选，在样品阶段通常都会设计
## S5PC100(集成SOC片上系统)存储结构
  - 片内设备
    - 寄存器组(37个)(内核级别)
    - Cache(ICache缓冲指令/DCache缓冲数据)(一级Cache32KB/二级Cache256KB)(缓冲级别)
    - SRAM(96KB)(片内存储)
  - 片外设备
    - DDRII(256MB)(有地址总线，板卡)
    - Nor(2MB)(同DDRII)
    - Nand(256MB)(外设)
***

# ARM体系结构
## ARM advanced RISC machine 系列芯片
  - Cordex-A 系列 600MHz 以上
  - ARM7、9、11 系列 200～600MHz
  - cordex-m 系列 50～150MHz
## ARM 数据和指令类型中断服务程序 ISR Interrupt Service Routines
  - ARM采用的是32位架构，支持数据包括32位(默认)、16位、8位
  - 大部分ARMcore提供
    - **ARM指令集** 32-bit字对齐，地址被4整除，低2位置零
    - **Thumb指令集** 16-bit半字对齐，地址被2整除，最低一位置零
  - CPU一个地址对应1字节，ARM中存储单元一个地址对应4字节
  - ARM处理器直接支持对齐的半字或字数据的存取，可以使用一条响应指令开实现对应操作，而对于非对齐的数据，则需要多条指令组合才能实现对应操作，这将影响程序执行效率
## ARM 处理器运行模式
  - **主要运行模式**
    - **用户模式** User / usr / 0x10，正常程序的工作模式
    - **快速中断模式** FIQ / fiq / 0x11，高优先级中断响应，用于告诉数据传输和通道处理
    - **外部中断模式** IRQ / irq0x12，低优先级中断响应，用于通常的中断处理
    - **特权模式** Supervisor / svc / 0x13，在系统复位和软件中断响应时进入该模式，供操作系统使用的一种保护模式，权限最高，在没有操作系统的情况下，正常程序处于该工作模式
    - **数据访问中止模式** Abort / abt / 0x17，存取异常时进入该模式，用于虚拟内存和存储器保护
    - **未定义指令中止模式** Ubdefined / und / 0x1B 执行未定义指令时进入该模式，用于支持通过软件仿真硬件的协处理器
    - **系统模式** System / sys / 0x1F 使用和User相同寄存器集的特权模式，具有直接切换到其他模式等特权，用于运行特权级的操作系统任务
  - **Cortex-A特有模式** Monitor为了安全而扩展出的用于执行安全监控代码的模式，也是一种特权模式
  - 除用户模式外其他6种称为 **特权模式**，其中除系统模式外其他5种又称为 **异常模式**
  - 每一种异常模式都有一组 **寄存器组**，而用户模式与系统模式使用相同的寄存器组，以此来保证当异常终端发生时任务状态不被破坏
  - 大多数用户程序运行在 **用户模式** 下，这时不能访问一些受操作系统保护的系统资源，应用程序也不能直接进行处理器模式切换，当需要切换时可以产生 **异常处理**，在异常处理的过程中进行 **处理器模式切换**
## ARM 寄存器 37个32位寄存器
  - 1个用作 **PC 程序计数器，R15**，指示程序的运行地址
  - 1个用作 **CPSR 程序状态寄存器**
    - **31~24** 位为 **标记域 f**，分别为 **NZCVQ[两位空]J**
      - N=1 表示 ALU 结果为负值
      - Z=1 表示 ALU 结果为0值
      - C=1 表示进借位
      - V=1 表示溢出
    - **23~16** 位为 **s**
    - **15~8** 位为 **x**
    - **7~0** 位为 **控制域 c**，分别为 **IFT[5位mode]**
      - I=1 表示禁止 IRQ
      - F=1 表示禁止 FIQ
      - T=1 表示Thumb工作状态，T=0 表示ARM工作状态
      - 5位 mode，表示工作模式
      ![](images/monitor_mode.png)
  - 5个用作 **SPSR 备份程序状态寄存器**，每个特权模式(5个)对应自己的SPSR，用于备份当前CPSR
  - 30个 **通用寄存器**
    - **R0~R7 未备份寄存器**，在所有的处理器模式下指的都是同一个物理寄存器
    - **R8~R14 备份寄存器**
      - R8~R12 对应两个不同的物理寄存器，Rn / Rn_fiq
      - R13 / R14 对应六个不同的物理寄存器，Rn_usr / svc / abt / und / irq / fiq
    - 在ARM指令集中 **R13** 常用做 **栈指针 SP**，**R14** 用作 **链接寄存器 LR**，存储异常终端发生的该异常模式将要返回的地址
  - **对齐** 存储器访问必须始终适当地保持地址对齐，非对齐地址将产生不可预测的结果
## ARM协处理器
  - 可定义16个协处理器，扩充ARM指令集
  - cp14 通常用作调试bug
  - cp15 通常用作ARM cache控制器
## Thumb指令集
  - 是ARM指令集的一个功能子集，可优化代码密度，提高窄内存操作性能
  - 条件执行不可用，只有低端寄存器可用
  - 使用BX命令在ARM与Thumb之间切换
## SOC概念
  - 是信息系统核心的芯片集成，是将系统关键部分集成在一块芯片上
  - ARM芯片(S5PC100) = ARM核(cortex-A8) + 片内存储器(SRAM等) + 片内控制器(控制外围设备)
  - AMBA总线是ARM环境中的继承总线标准，提供工作频率，集成在SOC中，分为AHB 高速 / APB 低速
## 指令流水线
  - 为增加处理器指令流的速度，ARM7系列使用 **3级流水线**，允许多个操作同时处理
  - 每条指令都要经过 **取指 / 解码 / 执行** 的过程
  - **PC** 指向正被取指的指令，而非正在执行的指令
    - 在编译器中，当前执行PC值 = 程序指针 PC(R15)
    - ARM 中 PC值(取值PC) = 当前执行PC + 8
    - Thumb 中 PC值(取值PC) = 当前执行PC + 4
    ```c
    add pc, pc, #4  ; pc = pc +4(代码中当pc为右值时指的是取指pc，左值则是R15)
                    ; R15 = 取指PC + 4
                    ;     = (执行PC + 8) + 4
                    ;     = (0x8 + 8) + 4 = 0x14
    ```
  - **最佳流水线** 指令周期数(CPI) = 1，但实际执行过程中如访存指令(LDR等)、分支跳转指令(BL)、中断等都会影响流水线的执行，因此，只有流水线被指令填满时才能发挥最大效能，尽量少地使用跳转指令可以提高程序的执行效率
  - ARM9 中采用 **5级流水线**，使用 **哈佛架构**，哈佛架构增加了可用的存储器宽度，可以实现对指令和数据存储器的同时访问
  - ARM10 中采用 **6级流水线**
  - ARM7 中读寄存器发生在指令执行阶段，ARM9 中读寄存器发生在译码阶段
  - 在ARM9的流水线中出现 **互锁** 的情况
    - 流水线中的两条指令对同一个寄存器进行了操作
    - 对寄存器组的访问
    - 以上两种情况的结合
***

# ARM 指令集
## 简介
  - **RISC 精简指令集**
    - 机器码是固定长度(16/32/64)
    - 指令规整，简单
    - 单周期执行，容易实现流水线机制
    - 采用大量寄存器
    - 访存指令，如加载 / 存储 / 交换
  - **分类**
    - 跳转指令
    - 数据处理指令
    - 程序状态寄存器 PSR 传输指令
    - Load / Store指令
    - 协处理指令
    - 异常中断产生指令
  - **指令格式**
    ```c
    操作码[+指令执行的条件][+S指令的操作是否影响CPSR] + 目标寄存器 + op1 + op2 + ...
    ```
## 指令的条件码 16个
  - 提高代码密度，减少分支跳转指令数量
  - EQ 相等，Z=1 / NE 不相等，Z=0
  - LT 有符号数小于N!=V / GT 有符号数大于Z=0，N=V
  - LE 有符号数小于或等于Z=1，N!=V / GE 有符号数大于或等于N=V
  - LO 无符号数小于C=0 / HI 无符号数大于C=1，Z=0
  - LS 无符号数小于或等于C=0，Z=1 / HS 无符号数大于或等于C=1
  - MI 负数N=1 / PL 正数或零N=0
  - VS 溢出V=1 / VC 没有溢出V=0
  - AL 无条件执行(默认) / NV 从不执行
  ```java
  CMP r3, #0          ; r3 - #0 == 0?
  BEQ skip            ; Z = 1执行
  ADD r0, r1, r2      ; Z = 0执行
  skip                ; 有分支跳转
  ```
## 操作数寻址方式
  - 立即数寻址：mov r0, #8
  - 寄存器寻址：mov r0, r1
  - 移位寻址：mov r0, r1, lsl #2
  - 寄存器间接寻址：ldr r0, [r1]
  - 基址寻址：ldr r0, [r1, #2]
  - 多寄存器寻址：ldmia r0!, {r0-r7}
  - 堆栈寻址：stmfd sp!, {r0-r7, lr}
## 立即数
  - 所有的ARM指令都是32bit固定长度，所以第二个操作数只能有12位
  - 机器码低12位：低8位是常数(immed_8)，高4位是循环右移位数(rotate_imm) * 2
  - 立即数由immed_8循环右移rotate_imm的两倍得到
  - 判断是否是立即数
    - 利用编译器
      ```java
      0x00000004 E3A004FF MOV R0， #0xFF000000
              低8位常数0xff，移位次数4 * 2 = 8(循环右移) = 循环左移(32 - 8 = 24)位
      ```
    - 规则
      - 找出8位常数：第一个1和最后一个1，最短距离不能超过8位
      - 判断8位常数能否循环右移偶数位得到
  - 在ARM中当立即数数值在0和0xFF之间时 rotate_imm = 0，其他情况下汇编器选择使 rotate_imm 数值最小的编码方式
  - 装载32bit常数：LDR rd, =const
    ```java
    LDR r0, =0xFF             ; ----> MOV r0, #0xFF
    LDR r0, =0x55555555       ; ----> LDR r0, [PC, #offset](PC寻址PC)
                              ;           ...
                              ;           DCD 0x55555555
    ```
## 分支跳转指令
  - 在ARM中有两种方式实现跳转，一种是跳转指令，一种是直接向PC中写入目标地址值(长跳转)
  - **B**：相当于goto label，不带返回地址
  - **BL**：相当于函数调用，编译器自动保存返回地址，但在进行嵌套调用时，由于一种模式中LR只有一个，所以应保存要返回的LR值，或是在使用BL之前切换其他工作模式
  - **跳转值** = 偏移量(机器码低24bit) (扩展为32位，扩展符号位 )* 4 + 当前PC值(取指PC)
  - **跳转范围**：±32MB
    ```c
    ...
    BL function
    ...
    function
    ...
    MOV PC, LR
    ```
  - 使用B/BL指令的程序不依赖于代码的存储位置，即 **位置无关指令**
  - **长跳转**
    ```c
    LDR pc, = label
    ADR pc, label        ;小范围
    ADRL pc, label        ;中等范围
    ```
## 数据处理指令
  - 只能对寄存器操作，不能针对存储器
  - ADD / ADC / SUB / SBC / RSB(逆向减法，代码的正交性) / RSC(C表示带进位的方式)
  - ADDS / SUBS 表示设置标志位
  - AND / ORR / EOR / NOT(按位取反) / BIC(按位清零，写1清零)
  - CMP / CMN(负值比较指令) / TST(位测试) / TEQ(位相等测试)
  - MOV / MVN(取反后赋值)
  - /=(不等于) / <>(不等于)
## 数据移位指令
  - 移位值是一个5bit无符号整数(32位)
  - LSL/LSR逻辑移位，无符号；ASR算数右移，保留符号位；
  - ROR循环右移位，左移量 = 32 - 右移量
## 其他指令
  - **BASE** 返回基于寄存器的表达式中的寄存器编号
  - **INDEX** 返回基于寄存器的表达式相对于其基址寄存器的偏移量
  - **DEF** 判断某个符号是否已定义
  - **?**：返回定义符号(如? A)的代码所生成的可执行代码的字节数
  - **\**：续行符
  - **$**：表示指令被汇编时将使用相应的值来代替$后的符号
    - 如果需要字符$则用$$代替
    - 对于数字变量，将该数字变量的数值转换成十六进制的串
    - 逻辑变量替换为T/F
    - 用 "." 来分割出变量名：STR2 SETS "bbb$STR1.CCC"
## 单寄存器数据传送 Load / Store 指令的寻址方式
  - **Load** 指令用于从内存中读取数据放入寄存器，**Store** 指令用于将寄存器中的数据保存到内存
    - LDR(读操作) 目标寄存器，[源寄存器]        (默认字操作)
    - STR(写操作) 源寄存器，[目标寄存器]        (默认字操作)
    - LDRB/STRB(字节操作)(高位清零)，LDRH/STRH(半字操作)(高位清零)
  - 指令中当 PC 作为目标寄存器时，实现程序跳转的功能
  - 通过使用 **!** 来自动更新基址寄存器
    ```java
    str r0, [r1, #12]!
    ```
  - **前索引 / 后索引**
    ```java
    前索引
        LDR r0, [r1, #8]
        int r0, *r1
        r0 = *(r1 + 8)
        ;不更新基址寄存器

    后索引
        LDR r0, [r1], #8
        int r0, *r1
        r0 = *r1
        r1 += 8;更新基址寄存器

    前索引!
        LDR r0, [r1, #8]!
        int r0, *r1
        r0 = *(r1 + 8)
        r1 += 8
    ```
  - **可带状态** I[25]P[24]U[23]W[21]
## 批量Load / Store指令的寻址方式(LDM / SDM)
  - 实现在一组寄存器和一块连续的内存单元之间传输数据，允许一次传送1到16个寄存器到/从存储器中
    - LDM(读操作) 源寄存器，[目标寄存器]
    - SDM(写操作) 源寄存器，[目标寄存器]
    - 格式：LDM/STM{<cond>}<addressing_mode> Rn{!}, <registers>{^}
      ```
      LDM r0, {r1, r2} / LDM r0, {r0 - r7}
      ```
    - 可带状态IA(先操作后增加)IB(先增加后操作)DA(先操作后递减)DB(先递减后操作)
    - 可选项 "!" 将导致LDM/STM指令去自动更新基址寄存器
    - 可选项 "^" 指示指令中执行时将当前处理器模式下的SPSR值复制到/从CPSR中，此时若寄存器列表中不含有PC寄存器，则指示指令中用到的寄存器为用户模式下的寄存器
  - 寄存器的传送顺序是固定的，编号低的寄存器总是被对应到存储器的低地址单元上
    ```c
    start
            ldr r8, =src
            mov r11, #0x10
            add r9, r8, r11, lsl #2
            ldr r10, =des

    copy
            ldmia r8!, {r0 - r7}
            stmia r10!, {r0 - r7}
            cmp r8, r9
            bne copy
    ```
  - ARM中堆栈操作通过 **块传递指令** 来完成
    - STMFD(压栈) 块存储，满递减[STMDB]
    - LDMFD(出栈) 块装载，满递减[LDMDA]
    - 满堆栈：堆栈指针指向最后入栈有效数据
    - 空堆栈：堆栈指针指向一个等待写入数据的空位值
    - 压栈时若堆栈为空，则第一个数据放在栈顶的下一个单元：（有问题！）
      ```c
      STMFD SP!, {R0 - R7, LR}
      ```
    - 异常处理的软件过程
      ```c
      function
      STMFD SP!, {r0- r12, LR}         ;进入程序时，保存现场
      ...
      LDMFD SP!, {r0- r12, PC}^        ;退出程序时，恢复现场
              //参数列表中同时有PC和"^"，表示SPSR_mode ---> CPSR，LR_mode --> PC
      ```
    - 能够运行代码的存储单元都可以用来开辟堆栈
    - 运行 C 语言 main 函数之前，必须确保堆栈空间已经被设置好了
## SWP / SWPB 软交换
  - 在寄存器和存储器之间，由一次存储器读和一次存储器写组成，原子操作，不被打断，可用做信号量操作；不能由armcc编译产生，必须使用汇编器
    ```c
    SWP {<cond>} {B} Rd, Rm, [Rn]        ；读出[Rn]中的内容放入Rd，同时将Rm中的内容放入[Rn]
    ```
## 软件中断 SWI
  - **SWI** 是一种用户自定义模式
    - 当执行到SWI指令时，处理器跳转到异常向量表0x8入口地址，自动切换到svc工作模式
    - 随后跳转到软中断散转表，并识别其软中断号，执行相应处理代码
  - 可实现在用户模式对操作系统中特权模式的程序调用，可将其封装
  - 格式
    ```c
    SWI <SWI number(24位软中断号)>        ；其中的软件中断号指定用户请求的服务类型，
                                  ；通过通用寄存器传递
    ```
  - ARM状态下软件中断号为24位，Thumb状态下为8位
## 断点中断指令 BKPT
  - 用于产生软件断点中断，用于调试程序，当时用硬件调试时可忽略该中断。
  - 格式
    ```c
    BKPT <immediate(16位)>        ;其中的立即数被调试软件用来保存额外的断点信息
    ```
## PSR 传送指令
  - MRS/MSR用于传送CPSR/SPSR中的内容到/从一个通用寄存器中。
  - 格式
    ```c
    MRS {<cond>} Rd, CPRS/SPRS
    MSR {<cond>} CPSR/SPSR_{fsxc}, Rm/#Immediate
    ```
    ```c
    MRS R0, CPRS                ;读取CPSR
    BIC R0, R0, #0x1F        ;修改，去除当前处理器模式
    ORR R0, R0, #0x13        ;修改，设置特权模式
    MSR CPSR_c, R0        ;写回，仅仅修改CPSR中的控制位域
    ```
  - 在用户模式下，所有位都可被读取，但只有f域可写
## 指令示例
  ```java
  mov r0, r2, lsr #24
  orr r3, r0, r3, lsl #8        ;r2的高8位送入r3的低8位

  add r0, r0, r0, lsl #2        ;r0 *= 5

  adds r0, r0, r2
  adc r1, r1, r3        ;r1/r3(高32位)、r0/r2(低32位)中存放的64位数据相加

  eor r1, r0, r0, ror #16        ;r1 = A^C, B^D, C^A, D^B
  bic r1, r1, #0xff0000        ;r1 = A^C, 0, C^A, D^B
  mov r0, r0, ror #8                ;r0 = D, A, B, C
  eor r0, r0, r1, lsr #8        ;r0 = A, B, C, D，实现字节序的转换，r0 = DCBA ----> r0 = ABCD

  cmp r0, #0
  cmpne r1, #1
  addeq r2, r3, r4                ;实现if (a == 0 || b == 1) {c = d + e;}

  llsearch
          cmp r0, #0
          ldrne r2, [r0], #4
          cmpne r1, r2
          bne llsearch
          ldrne r0, [r0, #-4]        ;将r0指向第一个匹配的元素
          mov pc, lr        ;遍历链表查找r1中的数据，链表的头节点在r0中，链表的每个元素包括两
                          ;个字，第一个字中包含数据，第二个字中包含指向下一个链表元素的地址

  strcmp
          ldrb r2, [r0], #1
          ldrb r3, [r1], #1
          cmp r2, #0
          cmpne r3, #0
          beq return
          cmp r2, r3
          beq strcmp
  return
          sub r0, r2, r3
          mov rc, lr                ;比较字符串r2与r3大小，结果存于r0中

  func
          cmp r0, #2
          moveqs pc, lr
          adr r3, jumpTable
          ldr pc, [r3, r0, lsl #2]

  jumpTable
          dcd subfunc
          dcd        addfunc

  addfunc
          add r0, r1, r2
          movs pc, lr
  subfunc
          sub r0, r1, r2
          movs pc, lr        ;依据r0中不同的值(0/1)实现不同的功能(+/-)
  ```
***

# ARM 中的伪指令(伪指令：运行时没有一一对应的机器码)
## 符号定义伪操作
  - GBLA/GBLL/GBLS声明一个全局变量(A算数L逻辑S串)
  - LCLA/LCLL/LCLS声明一个局部变量，局部变量的作用范围是包含该局部变量的宏代码的一个实例。
  - SETA/SETL/SETS给变量赋值
  - RLIST为通用寄存器列表定义名称：Contex RLIST {r0 - r6, r8, r10 - r12, r15}        ;可用在LDM/STM中
  - RN为一个特定的寄存器定义名称
  - CN为协处理器的寄存器定义名称：Power CN 6        ;将协处理器的寄存器6名称定义为Power
  - CP为协处理器定义名称：name CN expr        ;expr取值范围0~15
  - DN及SN为VFP的寄存器定义名称(D双精度(0~15)，S单精度(0~31))
  - FN为FPA的浮点寄存器定义名称name FN expr        ;expr取值范围0~7
## 数据定义伪操作
  - LTORG声明一个数据缓冲池(literal pool)的开始，一般放在END之前，防止作为指令执行
  - MAP(^)定义一个结构化的内存表(storage map)的首地址
    ```java
    MAP expr (, reister);首地址为expr+register
    ```
  - FIELD(#) 定义结构化的内存表中的一个数据域(field)，配合MAP来定义结构化内存表，仅仅定义数据结构，并不实际分配内存单元
    ```java
    MAP 4096
    consta FIELD 4
    string FILED 256
    ...
    LDR R6, consta
    ```
  - SPACE(%)分配一块内存单元，并用0初始化(label) SPACE expr
  - DCB(=)(字节)/DCW(半字)/DCD(&amp;)(字)/DCQ(双字)/DCFD(双精度浮点数双字)/DCFS(单精度浮点数)
    ```java
    Nullstring DCB "Nothing usful", 0
    ```
## 汇编控制伪操作
  - IF([) / ELSE(|) / ENDIF(]) 条件编译
  - WHILE / WEND 根据条件重复汇编一段代码
  - MACRO / MEND 宏定义
    ```c
    MACRO
    ($label) macroname ($parameter ... );$表示指令被汇编时将使用相应的值来代替$后的符号
    ...
    MEND
    ```
    ```c
    MACRO
    $label TestAndBranch $dest, $reg, $cc
    $label CMP $reg, #0
    B$cc $dest
    MEND

    调用：test TestAndBranch NonZero, r0, NE
    宏展开： test CMP r0, #0
            BNE NonZero
    ```
  - MEXIT 从宏中跳转出去
## 信息报告伪操作
  - ASSERT 断言
  - INFO 报告诊断信息
  - OPT 在源程序中设置列表选项
  - TTL 在列表文件的每一页的开头插入一个标题/SUBT在列表文件的每一页的开头插入一个子标题
## 其他的伪操作
  - ALIGN对齐方式，ALIGN (expr (, offset))，如ALIGN 8，则以8字节对齐
    ```c
    DCB 1
    ALIGN 4, 3
    DCB 1        ;将两个字节分别放在同一个字的第一字节和第四字节
    ```
  - AREA 用于定义一个代码段或数据段
    - CODE 代码段 / DATA 数据段 / NOINIT 未初始化段 / COMMON 通用段
    - ALIGN(不同于ALIGN伪代码) 代码段 / 数据段对齐方式属性，如ALIGN = 3，则以8字节对齐
  - CODE16 / CODE32 报告汇编编译器后面的指令序列是 16 / 32 位
    ```c
    AREA changeState, CODE, READONLY
    CODE32
    LDR r0, =start + 1
    BX r0
    CODE 16
    start MOV r1, #10
    ```
  - ENTRY (程序入口) / END (程序结尾，其后不可再有代码)
  - EQU 相当于#define，为一个常量定义字符名称
  - EXPORT(GLOBAL) 声明一个符号可以被其他文件引用 / IMPORT(EXTERN) 引入其他文件中定义的符号
  - GET(INCLUDE) 将一个源文件包含到当前源文件中，并进行汇编处理 / INCBIN 不进行汇编处理
  - ADR / ADRL / LDR
  - NOP 空操作伪指令
***

# ARM 中的存储系统
## 存储管理系统控制协处理器 CP15
  - 16个32位寄存器
  - MCR：ARM寄存器到协处理器寄存器的数据传送指令(系统模式下执行)
    ```c
    传送R4到CP15的C1寄存器中，其中的C0与其后的0位用于区分同一个编号的不同物理寄存器，指定为C0与0时表示不需要提供附加信息
    MCR P15, 0, R4, C1, C0, 0;
    ```
    ```c
    以下指令将异常中断向量表传送映射到0x20008000地址
    LDR R0, =0x20008000
    MCR P15, 0, R0, C12, C0, 0
    ```
  - MRC：协处理器寄存器到ARM寄存器的数据传送指令(系统模式下执行)，格式同上
  - 如果操作失败将产生未定义的指令异常中断
  - 寄存器C0是只读的，其中存放的是ARM相关的一些标识符
  - 寄存器C1是一个控制寄存器，包括
    - 禁止(0)/使能(1)MMU以及其他的与存储相关的功能，M[0]位
    - 配置存储系统以及ARM处理器中的相关部分的工作方式
    ```c
    使能MMU
    MRC P15, 0, R0, C1, C0, 0
    ORR R0, #01
    MCR P15, 0, R0, C1, C0, 0
    ```
## 存储器管理单元MMU
  - 实现从虚拟存储空间到物理存储空间的映射，ARM中采用页式虚拟内存管理
  - 存储器访问权限的控制
  - 设置虚拟存储空间的缓冲特性
***

# ARM 中异常处理
## 异常类型(中断向量表)
  - 复位(reset)(0x0, svc, 1)
  - 未定义的指令(undefined)(0x4, und, 6)
  - 软件中断(SWI)(0x8, svc, 6)
  - 指令预取中止(prefrech abort)(0x0c, abt, 5)
  - 数据访问中止(data abort)(0x10, abt, 2)
  - 保留(0x14)
  - 外部中断请求(IRQ)(0x18, irq, 4)
  - 快速中断请求(FIQ)(0x1c, fiq, 3)

  ![](images/017.png)
  - 在异常向量表中，FIQ的服务程序要位于0x1C(最高位)，因为为了实现快速响应，可直接将异常处理服务程序放置在0x1C之后的地址空间中，避免一条跳转指令的使用
## ARM 中的异常中断处理机制
  - 当异常产生时(硬件自动处理阶段)，ARMcore **保存被中断的程序的执行现场**
    - 备份 **CPSR** 到 **SPSR_<mode>**
    - 设置 **CPSR** 位
      - 改变处理器状态进入ARM态(CPSR[5] = 0)
      - 改变处理器模式进入相应的异常模式(CPSR[4:0] = mode)
      - 如果需要，则设置中断禁止位禁止相应中断(CPSR[7:6] = 11)
    - 返回地址(当前指令的一下条指令的地址)保存到 **LR_<mode>(R14)**
    - 设置 **PC(R15)** 为相应的异常向量(异常向量表中的相应跳转指令，存放于存储地址的低端)
    - 进入异常处理后，处理程序将 **R1~R7** 压入堆栈保护现场stmfd sp!, {r0 - r12, lr}
  - 当异常退出时(软件处理阶段)，**恢复被中断的程序的执行现场**
    - 从 **SPSR_<mode>** 恢复 **CPSR**
    - 从 **LR_<mode>** 恢复 **PC**
    - 从堆栈中恢复现场 **ldmfd sp!, {r0 - r12, pc}^**
  - 异常产生和异常退出时处理器必须处于 **ARM态执行**，因为Thumb指令集中没有相对应的异常处理指令(如只能访问R0~R7)
## 异常返回指令
  - 这些调整指令会与ldmfd sp!, {r0 - r12, pc}^作为同一条指令同时执行
  - 前提：在异常产生时内核设置lr_mode = pc - 4(pc为取指pc)
    ```c
    # 从SWI和Undef异常返回：(软件产生)
    movs pc, lr        ;pc = pc - 4

    # 从FIQ、IRQ异常返回：(硬件产生)
    subs pc, lr, #4        ;硬件会自动更新PC值pc = pc + 4，返回时应再减掉4，即pc = pc - 8

    # 从指令预取中止异常返回：(软件产生)
    subs pc, lr, #4        ;重新读取并执行该指令，pc = pc -8

    # 从数据异常(Data Abort)返回：(软件/硬件)
    subs pc, lr, #8        ;重新执行该指令，且由于当前pc值已更新，pc = pc -12
    ```
## 异常向量表跳转指令
  - b/bl label(32MB地址空间)
  - ldr pc, =label
  - ldr pc, label  ; label ----> 链接地址
    ```java
    Vector _Init_Block
    ldr pc, Reset_Addr
    ldr pc, Undefined_Addr
    ldr pc, SWI_Addr
    ldr pc, Prefretch_Addr
    ldr pc, Abort_Addr
    NOP
    ldr pc, IRQ_Addr
    ldr pc, FIQ_Addr

    Reset_Addr dcd Reset_Handler
    Undefiend_Addr dcd Undefiend_Handler
    SWI_Addr dcd SWI_Handler
    Prefretch_Addr dcd Prefretch_Handler
    Abort_Addr dcd Abort_Handler
    dcd 0
    IRQ_Addr dcd IRQ_Handler
    FIQ_Addr dcd FIQ_Handler
    ```
## IRQ / FIQ异常中断处理
  - 两级外部中断FIQ、IRQ，因此需要一个中断控制器来控制中断是如何传递给ARM的
  - C语言中可以使用 **_irq** 来说明一个不可重入(异常处理程序中不允许新的异常中断)的 IRQ / FIQ 异常处理程序，关键字 **_irq** 将会自动保存更多的寄存器，并调整函数的返回地址
  - **处理流程**
    - 建立异常向量表，并设置各种工作模式的堆栈空间，异常中断处理程序中使用的数据栈由用户提供
    - 正常程序(main函数)入口，----> 硬件初始化(中断控制器初始化)
    - 运行过程中产生中断，跳转到异常向量表的相应中断入口地址
    - 保护现场，调用ISR(中断服务程序Interrupt Service Routines)处理代码入口，处理ISR程序
    - 退出中断，包括恢复现场、调整返回地址
## SWI软中断处理
  - 通过调用C函数的返回值存于 **r0** 中
  - C中使用关键字 **__swi** 来定义一个软中断函数，允许最多4个参数，使用 **r0~r3** 来传递
  - 因为 **SWI** 调用要切换到 svc 模式，所以不能使用堆栈来传递参数
  - **识别软件中断号**
    - 判断SPSR_mode[5]，得到swi指令的运行地址
      ```c
      SPSR_mode[5] = 0 ----> ARM态   ： LR - 4
      SPSR_mode[5] = 1 ----> Thumb态：LR - 2
      ```
    - 根据运行地址(LR - 4/LR - 2)，读取机器码，并得到软件中断号
      ```c
      SPSR_mode[5] = 0，ARM态：[23:0]
      SPSR_mode[5] = 1，Thumb态：[7:0]
      ```
  - **软中断处理示例**
    ```c
    T_bit equ 0x20
    SWI_handler
        stmfd sp!, {r0 - r3, r12, lr}
        mov r1, sp                ;寄存器压栈，设置堆栈指针
        mrs r0, spsr
        stmfd sp!, {r0}        ;取出spsr，并压栈保存
        tst r0, #T_bit
        ldrneh r0, [lr, #-2]
        bicne r0, r0, #0xff00
        ldreq r0, [lr, #-4]
        biceq r0, r0, #ff000000        ;判断工作状态，提取软件中断号

        CMP R0, #10        ;判断SWI中断号是否在有效范围内
        LDRLS PC, [PC, R0, LSL #2]        ;如果是有效中断号，则跳转到相关的中断号服务
        B SWIOutOfRange        ;如果不在有效范围，则跳转SWIOutOfRange
    ```
## 复位异常中断处理程序
  - 启动代码，不需要返回
  - 建立异常向量表
  - 关闭看门狗
  - 硬件初始化(存储设备、关键I/O设备等)
  - 设置各种工作模式的堆栈
  - main函数入口
  - 对于嵌入式系统
    - 复位时RAM中是不存在代码和数据的，因此在系统复位时，地址0x0处应该为ROM
    - 因此在复位时，通常系统中的存储映射机构将ROM映射到地址0x0处
    - 然后在程序执行的最初几条指令中，进行地址重映射，将RAM映射到0x0处
***

# 清BSS段例程(初始值为0、无初始值的全局变量、静态变量放在BSS段)
  ```java
  clear_bss:
          ldr r0, =bss_start
          ldr r1, =bss_end
          mov r2, #0x00000000
  clear_loop:
          str r2, [r0], #4
          cmp r1, r0
          bne clear_loop
  ```
***

# C / 汇编编译器提示和技巧
  - 优化和调试
    - 优化可以提高代码密度
    - 调试可以有更多的调试信息
  - C的关键字volatile强制不进行优化
    ```c
    #define GPG3CON (* (volatile unsigned long * )0xe03001c0)
    ```
  - **ATPCS** ARM/Thumb程序调用规范，包括了寄存器的使用、数据栈的使用、参数传递的规则
    - 当参数不超过4个时，使用R0~R3来传递，超过4个时使用栈传递
    - 注意入栈的顺序与参数传递顺序相反，即最后一个参数先入栈
    - 子程序的返回结果，32位整数通过R0返回，64位整数通过R0和R1返回
***

# ARM 映像文件
  - 一个映像文件由一个或多个域组成，一个域通常映射到一个物理存储器上
  - 每个域包含一个或多个(1~3)输出段，其中各输出段的属性各不相同，其排列顺序由其属性决定，依次为RO段，RW段，ZI段
  - 每个输出段包含一个或多个输入段，一个输出段中的输入段属性相同
  - 输入段中包含了4类内容，代码/已初始化数据/未初始化的存储区域/初始化为0的存储区域，每个输入段有相应属性，只读(RO)/可读写(RW)/初始化为0(ZI)
***

# Linux 内核中使用汇编代码
  - 需要使用汇编代码的场景
    - 直接与硬件交互的底层程序，如设置段寄存器
    - CPU中没有C语言对应成分的特殊指令，如开关中断
    - 内核中频繁调用的某些操作的过程、程序段或函数，如系统调用的进入和返回
    - 对程序空间效率要求高的场合，如操作系统的引导程序通常要能容纳在磁盘的第一个扇区中
    - 需要精确控制CPU执行空指令所消耗时间的指令
  - C代码中插入汇编成分的一般格式
    ```c
    指令部 : 输出部 : 输入部 : 损坏部  // 其中指令部时必须有的
    ```
    ```c
    static __inline__ void atomic_add(int i, atomic_t *v) {
        __asm__ __volatile__ (  // 这里要求整个操作只由一条指令完成，并且要将总线锁住，以保证操作的原子性
            LOCK "addl %1, %0"  // %n表示使用寄存器的样板操作数，其编号对应从输出部的第一个约束顺序数下来
                                // 其中LOCK表示执行addl指令时要把系统的总线锁住
            :"=m" (v->counter)  // 输出部用于规定对目标操作数如何结合，以"="开头
                                // m表示目标操作数(%0)是一个内存单元(v->counter)
            :"ir" (i), "m" (v->counter));  // 此处输入部有两个约束，第一个"ir"表示指令中的%1
                                // 可以是一个在寄存器中的直接操作数(来自于i)
    }
    ```
***

# ARM 与 C 混合编程
## 寄存器使用规则
  - 子程序间通过寄存器R0～R3传递参数，寄存器R0～R3可记作A1～A4。被调用的子程序在返回前无须恢复寄存器R0～R3的内容
  - 在子程序中，ARM状态下使用寄存器R4～R11来保存局部变量，寄存器R4～R11可记作V1～V8；Thumb状态下只能使用R4～R7来保存局部变量
  - 寄存器R12用作子程序间调用时临时保存栈指针，函数返回时使用该寄存器进行出栈，记作IP；在子程序间的链接代码中常有这种使用规则
  - 通用寄存器R13用作数据栈指针，记作SP
  - 通用寄存器R14用作链接寄存器
  - 通用寄存器R15用作程序计数器，记作PC
## 数据栈使用规则
  - 过程调用标准规定数据栈为FD类型，并且对数据栈的操作时要求8字节对齐的
## 参数传递规则
  - 参数个数可变的子程序参数传递规则，对于参数个数可变的子程序，当参数个数不超过4个时，可以使用寄存器R0～R3来传递；当参数个数超过4个时，还可以使用数据栈进行参数传递
  - 参数个数固定的子程序参数传递规则
    - 如果系统不包含浮点运算的硬件部件且没有浮点参数时，则依次将各参数传送到寄存器R0～R3中，如果参数个数多于4个，将剩余的字数据通过数据栈来传递
    - 如果包括浮点参数则要通过相应的规则将浮点参数转换为整数参数，然后依次将各参数传送到寄存器R0～R3中。如果参数多于4个，将剩余字数据传送到数据栈中，入栈的顺序与参数序相反，即最后一个字数据先入栈
  - 如果系统包含浮点运算的硬件部件，将按照如下规则传递
    - 各个浮点参数按顺序处理，为每个浮点参数分配寄存器。分配方法是：找到编号最小的满足该浮点参数需要的一组连续的FP寄存器进行参数传递
## 子程序结果返回规则
  - 结果为一个32位的整数时，通过寄存器R0返回；结果为一个64位整数时，通过寄存器R0，R1返回
  - 结果为一个浮点数时，可以通过浮点运算部件的寄存器F0、D0或者S0来返回
  - 结果为复合型的浮点数（如复数）时，可以通过寄存器F0～Fn或者Ｄ0～Ｄn来返回
  - 对于位数更多的结果，需要通过内存来传递
## 汇编调用C代码中标号（函数、变量）举例
  - 在汇编的源程序中调用C语言风格的字符串需要使用.extern伪操作（同C中的关键字extern），声明被引用的标号为外部标号
  - C语言文件test.c 中有函数如下
    ```c
    int x;
    int add_func(int a, int b) {
        return (a+b);
    }
    ```
  - 在汇编语言中，要引用该函数，则需要
    ```c
    // 声明
    .extern add_func

    // 调用函数
    mov r0， #1 @传递参数a给r0
    mov r1, #2 @传递参数b给r1
    bl add_func @调用add_func函数
    ```
    此时r0存放a+b结果
  - 如果需要在汇编语言中引用test.c中的全局变量x，方法和引用函数类似
    ```c
    // 声明为外部标号
    .extern x

    // 引用变量
    ldr r0, =x
    ldr r0, [r0]
    ```
## C程序引用汇编代码中标号举例
  - 汇编语言代码中需要将被引用的标号声明成全局标号
  - 在C语言程序中将该标号声明成外部标号
  - 在C语言程序中引用
  - 示例
    ```c
    汇编语言代码
    .text
    .global mystrcopy
    mystrcopy：
    LDRB r2, [r1], #1
    STRB r2, [r0], #1
    CMP r2, #0
    BNE mystrcopy
    BX lr
    ```
    ```c
    C语言代码
    extern void mystrcopy(char *d, const char *s);
    int main(void) {
        const char * src = “Source”;
        char dest[10];
        ...
        mystrcopy(dest, src);
        ...
    }
    ```
***
